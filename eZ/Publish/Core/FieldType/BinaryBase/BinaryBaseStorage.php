<?php
/**
 * File containing the BinaryBaseStorage class
 *
 * @copyright Copyright (C) 1999-2013 eZ Systems AS. All rights reserved.
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License v2
 * @version //autogentag//
 */

namespace eZ\Publish\Core\FieldType\BinaryBase;

use eZ\Publish\Core\FieldType\GatewayBasedStorage;
use eZ\Publish\Core\FieldType\FileService;
use eZ\Publish\SPI\Persistence\Content\VersionInfo;
use eZ\Publish\SPI\Persistence\Content\Field;

/**
 * Storage for binary files
 */
class BinaryBaseStorage extends GatewayBasedStorage
{
    /**
     * File service to be used
     *
     * @var FileService
     */
    protected $fileService;

    /**
     * Path generator
     *
     * @var PathGenerator
     */
    protected $pathGenerator;

    /**
     * Construct from gateways
     *
     * @param \eZ\Publish\Core\FieldType\StorageGateway[] $gateways
     * @param FileService $fileService
     * @param PathGenerator $pathGenerator
     */
    public function __construct( array $gateways, FileService $fileService, PathGenerator $pathGenerator )
    {
        parent::__construct( $gateways );
        $this->fileService = $fileService;
        $this->pathGenerator = $pathGenerator;
    }

    /**
     * Allows custom field types to store data in an external source (e.g. another DB table).
     *
     * Stores value for $field in an external data source.
     * The whole {@link eZ\Publish\SPI\Persistence\Content\Field} ValueObject is passed and its value
     * is accessible through the {@link eZ\Publish\SPI\Persistence\Content\FieldValue} 'value' property.
     * This value holds the data filled by the user as a {@link eZ\Publish\Core\FieldType\Value} based object,
     * according to the field type (e.g. for TextLine, it will be a {@link eZ\Publish\Core\FieldType\TextLine\Value} object).
     *
     * $field->id = unique ID from the attribute tables (needs to be generated by
     * database back end on create, before the external data source may be
     * called from storing).
     *
     * The context array provides some context for the field handler about the
     * currently used storage engine.
     * The array should at least define 2 keys :
     *   - identifier (connection identifier)
     *   - connection (the connection handler)
     * For example, using Legacy storage engine, $context will be:
     *   - identifier = 'LegacyStorage'
     *   - connection = {@link \eZ\Publish\Core\Persistence\Legacy\EzcDbHandler} object handler (for DB connection),
     *                  to be used accordingly to
     *                  {@link http://incubator.apache.org/zetacomponents/documentation/trunk/Database/tutorial.html ezcDatabase} usage
     *
     * @param \eZ\Publish\SPI\Persistence\Content\VersionInfo $versionInfo
     * @param \eZ\Publish\SPI\Persistence\Content\Field $field
     * @param array $context
     *
     * @return void
     */
    public function storeFieldData( VersionInfo $versionInfo, Field $field, array $context )
    {
        if ( $field->value->externalData === null )
        {
            // Nothing to store
            return false;
        }

        $storedValue = $field->value->externalData;

        if ( !$this->fileService->exists( $storedValue['path'] ) )
        {
            // Only store a new file copy, if it does not exist, yet
            $targetPath = $this->pathGenerator->getStoragePathForField( $field, $versionInfo );

            $storedValue['path'] = $this->fileService->storeFile(
                $storedValue['path'],
                $this->fileService->getStorageIdentifier( $targetPath )
            );
        }

        $field->value->externalData = $storedValue;

        $this->removeOldFile( $field->id, $versionInfo->versionNo, $context );

        return $this->getGateway( $context )->storeFileReference( $versionInfo, $field );
    }

    /**
     * Removes the old file referenced by $fieldId in $versionNo, if not
     * referenced else where
     *
     * @param mixed $fieldId
     * @param string $versionNo
     * @param array $context
     *
     * @return void
     */
    protected function removeOldFile( $fieldId, $versionNo, array $context )
    {
        $gateway = $this->getGateway( $context );

        $fileReference = $gateway->getFileReferenceData( $fieldId, $versionNo );
        if ( $fileReference === null )
        {
            // No previous file
            return;
        }

        $gateway->removeFileReference( $fieldId, $versionNo );

        $fileCounts = $gateway->countFileReferences( array( $fileReference['path'] ) );

        if ( $fileCounts[$fileReference['path']] === 0 )
        {
            $this->fileService->remove( $fileReference['path'] );
        }
    }

    /**
     * Populates $field value property based on the external data.
     * $field->value is a {@link eZ\Publish\SPI\Persistence\Content\FieldValue} object.
     * This value holds the data as a {@link eZ\Publish\Core\FieldType\Value} based object,
     * according to the field type (e.g. for TextLine, it will be a {@link eZ\Publish\Core\FieldType\TextLine\Value} object).
     *
     * @param \eZ\Publish\SPI\Persistence\Content\VersionInfo $versionInfo
     * @param \eZ\Publish\SPI\Persistence\Content\Field $field
     * @param array $context
     *
     * @return void
     */
    public function getFieldData( VersionInfo $versionInfo, Field $field, array $context )
    {
        $field->value->externalData = $this->getGateway( $context )->getFileReferenceData( $field->id, $versionInfo->versionNo );

        if ( $field->value->externalData !== null )
        {
            $field->value->externalData['fileSize'] = $this->fileService->getFileSize( $field->value->externalData['path'] );
        }
    }

    /**
     * @param array $fieldIds
     * @param array $context
     *
     * @return boolean
     */
    public function deleteFieldData( VersionInfo $versionInfo, array $fieldIds, array $context )
    {
        $gateway = $this->getGateway( $context );

        $referencedFiles = $gateway->getReferencedFiles( $fieldIds, $versionInfo->versionNo );

        $gateway->removeFileReferences( $fieldIds, $versionInfo->versionNo );

        $referenceCountMap = $gateway->countFileReferences( $referencedFiles );

        foreach ( $referenceCountMap as $filePath => $count )
        {
            if ( $count === 0 )
            {
                $this->fileService->remove( $filePath );
            }
        }
    }

    /**
     * Checks if field type has external data to deal with
     *
     * @return boolean
     */
    public function hasFieldData()
    {
        return true;
    }

    /**
     * @param \eZ\Publish\SPI\Persistence\Content\VersionInfo $versionInfo
     * @param \eZ\Publish\SPI\Persistence\Content\Field $field
     * @param array $context
     *
     * @return void
     */
    public function getIndexData( VersionInfo $versionInfo, Field $field, array $context )
    {

    }
}
